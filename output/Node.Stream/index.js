// Generated by purs version 0.15.15
import * as $foreign from "./foreign.js";
import * as Control_Category from "../Control.Category/index.js";
import * as Data_Either from "../Data.Either/index.js";
import * as Data_Functor from "../Data.Functor/index.js";
import * as Data_Maybe from "../Data.Maybe/index.js";
import * as Data_Nullable from "../Data.Nullable/index.js";
import * as Data_Show from "../Data.Show/index.js";
import * as Effect from "../Effect/index.js";
import * as Effect_Exception from "../Effect.Exception/index.js";
import * as Effect_Uncurried from "../Effect.Uncurried/index.js";
import * as Node_Buffer from "../Node.Buffer/index.js";
import * as Node_Encoding from "../Node.Encoding/index.js";
import * as Node_EventEmitter from "../Node.EventEmitter/index.js";
import * as Unsafe_Coerce from "../Unsafe.Coerce/index.js";
var show = /* #__PURE__ */ Data_Show.show(Node_Encoding.showEncoding);
var identity = /* #__PURE__ */ Control_Category.identity(Control_Category.categoryFn);
var map = /* #__PURE__ */ Data_Functor.map(Effect.functorEffect);
var writeableNeedDrain = function (w) {
    return function () {
        return $foreign.writeableNeedDrainImpl(w);
    };
};
var writeableLength = function (w) {
    return function () {
        return $foreign.writeableLengthImpl(w);
    };
};
var writeableHighWaterMark = function (w) {
    return function () {
        return $foreign.writeableHighWaterMarkImpl(w);
    };
};
var writeableFinished = function (w) {
    return function () {
        return $foreign.writeableFinishedImpl(w);
    };
};
var writeableEnded = function (w) {
    return function () {
        return $foreign.writeableEndedImpl(w);
    };
};
var writeableCorked = function (w) {
    return function () {
        return $foreign.writeableCorkedImpl(w);
    };
};
var writeable = function (w) {
    return function () {
        return $foreign.writeableImpl(w);
    };
};
var writeString$prime = function (w) {
    return function (enc) {
        return function (str) {
            return function (cb) {
                return function () {
                    return $foreign.writeStringCbImpl(w, str, Node_Encoding.encodingToNode(enc), function (err) {
                        return cb(Data_Nullable.toMaybe(err))();
                    });
                };
            };
        };
    };
};
var writeString = function (w) {
    return function (enc) {
        return function (str) {
            return function () {
                return $foreign.writeStringImpl(w, str, Node_Encoding.encodingToNode(enc));
            };
        };
    };
};
var write$prime = function (w) {
    return function (b) {
        return function (cb) {
            return function () {
                return $foreign.writeCbImpl(w, b, function (err) {
                    return cb(Data_Nullable.toMaybe(err))();
                });
            };
        };
    };
};
var write = function (w) {
    return function (b) {
        return function () {
            return $foreign.writeImpl(w, b);
        };
    };
};
var unpipeH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("unpipe", Effect_Uncurried.mkEffectFn1);
})();
var unpipeAll = function (r) {
    return function () {
        return $foreign.unpipeAllImpl(r);
    };
};
var unpipe = function (r) {
    return function (w) {
        return function () {
            return $foreign.unpipeImpl(r, w);
        };
    };
};
var uncork = function (w) {
    return function () {
        return $foreign.uncorkImpl(w);
    };
};
var toEventEmitter = Unsafe_Coerce.unsafeCoerce;
var setEncoding = function (r) {
    return function (enc) {
        return function () {
            return $foreign.setEncodingImpl(r, show(enc));
        };
    };
};
var setDefaultEncoding = function (r) {
    return function (enc) {
        return function () {
            return $foreign.setDefaultEncodingImpl(r, show(enc));
        };
    };
};
var resumeH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("resume", identity);
})();
var resume = function (r) {
    return function () {
        return $foreign.resumeImpl(r);
    };
};
var readableLength = function (r) {
    return function () {
        return $foreign.readableLengthImpl(r);
    };
};
var readableHighWaterMark = function (r) {
    return function () {
        return $foreign.readableHighWaterMarkImpl(r);
    };
};
var readableH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("readable", identity);
})();
var readableFromString = function (str) {
    return function (enc) {
        return function () {
            return $foreign.readableFromStrImpl(str, Node_Encoding.encodingToNode(enc));
        };
    };
};
var readableFromBuffer = function (buf) {
    return function () {
        return $foreign.readableFromBufImpl(buf);
    };
};
var readableFlowing = function (r) {
    return function () {
        return $foreign.readableFlowingImpl(r);
    };
};
var readableEnded = function (r) {
    return function () {
        return $foreign.readableEndedImpl(r);
    };
};
var readable = function (r) {
    return function () {
        return $foreign.readableImpl(r);
    };
};
var readEither$prime = function (r) {
    return function (size) {
        return function __do() {
            var chunk = $foreign.readSizeImpl(r, size);
            var v = Data_Nullable.toMaybe(chunk);
            if (v instanceof Data_Maybe.Nothing) {
                return Data_Maybe.Nothing.value;
            };
            if (v instanceof Data_Maybe.Just) {
                return $foreign.readChunkImpl(function ($26) {
                    return Data_Maybe.Just.create(Data_Either.Right.create($26));
                }, function ($27) {
                    return Data_Maybe.Just.create(Data_Either.Left.create($27));
                }, v.value0);
            };
            throw new Error("Failed pattern match at Node.Stream (line 252, column 3 - line 259, column 10): " + [ v.constructor.name ]);
        };
    };
};
var readEither = function (r) {
    return function __do() {
        var chunk = $foreign.readImpl(r);
        var v = Data_Nullable.toMaybe(chunk);
        if (v instanceof Data_Maybe.Nothing) {
            return Data_Maybe.Nothing.value;
        };
        if (v instanceof Data_Maybe.Just) {
            return $foreign.readChunkImpl(function ($28) {
                return Data_Maybe.Just.create(Data_Either.Right.create($28));
            }, function ($29) {
                return Data_Maybe.Just.create(Data_Either.Left.create($29));
            }, v.value0);
        };
        throw new Error("Failed pattern match at Node.Stream (line 238, column 3 - line 245, column 10): " + [ v.constructor.name ]);
    };
};
var read$prime = function (r) {
    return function (size) {
        return function __do() {
            var chunk = $foreign.readSizeImpl(r, size);
            var v = Data_Nullable.toMaybe(chunk);
            if (v instanceof Data_Maybe.Nothing) {
                return Data_Maybe.Nothing.value;
            };
            if (v instanceof Data_Maybe.Just) {
                return $foreign.readChunkImpl(function (buf) {
                    return new Data_Maybe.Just(buf);
                }, function (v1) {
                    return Effect_Exception["throw"]("Stream encoding should not be set")();
                }, v.value0);
            };
            throw new Error("Failed pattern match at Node.Stream (line 187, column 3 - line 194, column 10): " + [ v.constructor.name ]);
        };
    };
};
var readString$prime = function (r) {
    return function (size) {
        return function (enc) {
            return function __do() {
                var mbBuf = read$prime(r)(size)();
                if (mbBuf instanceof Data_Maybe.Nothing) {
                    return Data_Maybe.Nothing.value;
                };
                if (mbBuf instanceof Data_Maybe.Just) {
                    return map(Data_Maybe.Just.create)(Node_Buffer.toString(enc)(mbBuf.value0))();
                };
                throw new Error("Failed pattern match at Node.Stream (line 227, column 3 - line 231, column 39): " + [ mbBuf.constructor.name ]);
            };
        };
    };
};
var read = function (r) {
    return function __do() {
        var chunk = $foreign.readImpl(r);
        var v = Data_Nullable.toMaybe(chunk);
        if (v instanceof Data_Maybe.Nothing) {
            return Data_Maybe.Nothing.value;
        };
        if (v instanceof Data_Maybe.Just) {
            return $foreign.readChunkImpl(function (buf) {
                return new Data_Maybe.Just(buf);
            }, function (v1) {
                return Effect_Exception["throw"]("Stream encoding should not be set")();
            }, v.value0);
        };
        throw new Error("Failed pattern match at Node.Stream (line 172, column 3 - line 179, column 10): " + [ v.constructor.name ]);
    };
};
var readString = function (r) {
    return function (enc) {
        return function __do() {
            var mbBuf = read(r)();
            if (mbBuf instanceof Data_Maybe.Nothing) {
                return Data_Maybe.Nothing.value;
            };
            if (mbBuf instanceof Data_Maybe.Just) {
                return map(Data_Maybe.Just.create)(Node_Buffer.toString(enc)(mbBuf.value0))();
            };
            throw new Error("Failed pattern match at Node.Stream (line 209, column 3 - line 213, column 39): " + [ mbBuf.constructor.name ]);
        };
    };
};
var pipeline = function (src) {
    return function (transforms) {
        return function (dest) {
            return function (cb) {
                return function () {
                    return $foreign.pipelineImpl(src, transforms, dest, function (err) {
                        return cb(Data_Nullable.toMaybe(err))();
                    });
                };
            };
        };
    };
};
var pipeH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("pipe", Effect_Uncurried.mkEffectFn1);
})();
var pipe$prime = function (r) {
    return function (w) {
        return function (o) {
            return function () {
                return $foreign.pipeCbImpl(r, w, o);
            };
        };
    };
};
var pipe = function (r) {
    return function (w) {
        return function () {
            return $foreign.pipeImpl(r, w);
        };
    };
};
var pauseH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("pause", identity);
})();
var pause = function (r) {
    return function () {
        return $foreign.pauseImpl(r);
    };
};
var isPaused = function (r) {
    return function () {
        return $foreign.isPausedImpl(r);
    };
};
var finishH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("finish", identity);
})();
var errored = function (rw) {
    return function () {
        return $foreign.erroredImpl(rw);
    };
};
var errorH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("error", Effect_Uncurried.mkEffectFn1);
})();
var endH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("end", identity);
})();
var end$prime = function (w) {
    return function (cb) {
        return function () {
            return $foreign.endCbImpl(w, function (err) {
                return cb(Data_Nullable.toMaybe(err))();
            });
        };
    };
};
var end = function (w) {
    return function () {
        return $foreign.endImpl(w);
    };
};
var drainH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("drain", identity);
})();
var destroyed = function (w) {
    return function () {
        return $foreign.destroyedImpl(w);
    };
};
var destroy$prime = function (w) {
    return function (e) {
        return function () {
            return $foreign.destroyErrorImpl(w, e);
        };
    };
};
var destroy = function (w) {
    return function () {
        return $foreign.destroyImpl(w);
    };
};
var dataHStr = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("data", function (cb) {
        return function (chunk) {
            return $foreign.readChunkImpl(function (v) {
                return Effect_Exception["throw"]("Got a Buffer, not String. Stream encoding must be set to get a String.")();
            }, Effect_Uncurried.mkEffectFn1(cb), chunk);
        };
    });
})();
var dataHEither = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("data", function (cb) {
        return function (chunk) {
            return $foreign.readChunkImpl(function ($30) {
                return cb(Data_Either.Left.create($30))();
            }, function ($31) {
                return cb(Data_Either.Right.create($31))();
            }, chunk);
        };
    });
})();
var dataH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("data", function (cb) {
        return function (chunk) {
            return $foreign.readChunkImpl(Effect_Uncurried.mkEffectFn1(cb), function (v) {
                return Effect_Exception["throw"]("Got a String, not a Buffer. Stream encoding should not be set")();
            }, chunk);
        };
    });
})();
var cork = function (s) {
    return function () {
        return $foreign.corkImpl(s);
    };
};
var closed = function (w) {
    return function () {
        return $foreign.closedImpl(w);
    };
};
var closeH = /* #__PURE__ */ (function () {
    return new Node_EventEmitter.EventHandle("close", identity);
})();
var allowHalfOpen = function (d) {
    return function () {
        return $foreign.allowHalfOpenImpl(d);
    };
};
export {
    newPassThrough
} from "./foreign.js";
export {
    toEventEmitter,
    closeH,
    errorH,
    drainH,
    finishH,
    pipeH,
    unpipeH,
    dataH,
    dataHStr,
    dataHEither,
    pauseH,
    readableH,
    resumeH,
    endH,
    readable,
    readableEnded,
    readableFlowing,
    readableHighWaterMark,
    readableLength,
    resume,
    pause,
    isPaused,
    pipe,
    pipe$prime,
    unpipe,
    unpipeAll,
    read,
    read$prime,
    readString,
    readString$prime,
    readEither,
    readEither$prime,
    writeable,
    writeableEnded,
    writeableCorked,
    errored,
    writeableFinished,
    writeableHighWaterMark,
    writeableLength,
    writeableNeedDrain,
    write,
    write$prime,
    writeString,
    writeString$prime,
    cork,
    uncork,
    setEncoding,
    setDefaultEncoding,
    end,
    end$prime,
    destroy,
    destroy$prime,
    closed,
    destroyed,
    allowHalfOpen,
    pipeline,
    readableFromString,
    readableFromBuffer
};
